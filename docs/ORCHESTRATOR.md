# Orchestrator

Сервис, управляющий процессом миграции данных из Steam. Ставит задачи **Worker'ам** и ведет учет запрошенных приложений.

## Стек

- [Pika](https://pika.readthedocs.io/en/stable/) - биндинг [RabbitMQ](https://www.rabbitmq.com/) для взаимодействия с сервисами-worker'ами
- [Celery](https://docs.celeryq.dev/en/stable/) - фреймворк для асинхронного выполнения задач / асинхронная очередь задач
- [Celery Beat](https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html) - планировщик задач для Celery
- [Redis](https://redis.io/) - брокер сообщений для Celery
- [PostgreSQL](https://www.postgresql.org/) - БД для ведения учета запрошенных приложений
- [FastAPI](https://fastapi.tiangolo.com/) - Web-фреймворк для построения API
- [SQLAlchemy 2.0](https://www.sqlalchemy.org/) - ORM с поддержкой асинхронной работы
- [Pydantic](https://pydantic-docs.helpmanual.io/) - Сериализация и валидация для FastAPI и [pydantic-settings](https://pydantic-docs.helpmanual.io/usage/settings/) для работы с переменными окружения
- [Uvicorn](https://www.uvicorn.org/) - ASGI-сервер для API

## Как устроен

Оркестратор состоит из **4** процессов:

## Основной процесс

Основной процесс бесконечно слушает очередь RabbitMQ, предназначенную для поступающих от worker'ов сообщений.
Этот процесс не ставит задачи worker'ам, а только принимает их отчеты о выполнении поставленных задач.
"Отчетами" являются встречные задачи, в которых worker'ы запрашивают обновление статуса приложения, успешно запрошенного ими из Steam и запушенного в Backend.

Оркестратор ведет базу, которая состоит из 1 таблицы. Таблица - список всех приложений в Steam вида `(id, last_updated)`. Поле `last_updated` содержит время последнего обновления данных об игре в главной БД. По умолчанию это значение равно 1 январю 1970 года.

От worker'ов приходит 2 типа задач:
- > _Актуализируй список id всех приложений в Steam_
- > _Обнови поле `last_updated` приложений с ID [1, 2, 3]_

**Первая задача** ставится worker'ом в ответ на задачу Оркестратора об актуализации списка приложений. К сообщению с этой задачей worker прикладывает актуальный список ID всех приложений в Steam.
Оркестратор сверяет список с текущим в БД и дополняет его.

**Вторая задача** ставится worker'ом в ответ на задачу Оркестратора о запросе данных об приложениях с ID [1, 2, 3]. К сообщению с этой задачей worker прикладывает список ID успешно запрошенных и запушенных в Backend приложений.
Оркестратор меняет значение поля `last_updated` на текущее время.

Обработкой полученных от RabbitMQ сообщений занимается сущность `TaskManager`. Она содержит обработчики приходящих задач, механизмы постановки задач для worker'ов, интерфейс для взаимодействия с RabbitMQ и фабрику SQLAlchemy-сессий.
Последовательность действия `TaskManager` при получении очередного сообщения из очереди RabbitMQ:
1. По содержимому сообщения определяется тип задачи
2. Выполняется соответствующий алгоритм решения задачи
3. Пришедшее RabbitMQ сообщение подтверждается, если задача успешно выполнилась, иначе отклоняется.

## Планировщик задач: Celery Worker & Celery Beat

Постановкой задач worker'ам занимается Celery, а точнее второй процесс Celery Beat, который триггерит эти задачи по расписанию.
Celery использует интерфейс `TaskManager` для постановки задач, которые бывают 2 типов:

- > _Получи список id всех приложений в Steam_
- > _Получи данные об приложениях с ID [1, 2, 3] в странах ["A", "B", "C"]_

**Первая задача** говорит worker'у, что он должен запросить у Steam список ID всех приложений и отправить его обратно в рамках отдельной задачи, обработкой которой займется основной процесс.

**Вторая задача** содержит список ID приложений, которые нужно запросить у Steam в контексте указанных стран (декартово произведение списка стран и списка ID приложений).
Список содержит ID приложений, у которых самая ранняя дата обновления `last_updated` (Запрашиваются приложения с самыми устаревшими/отсутствующими датами).

## API

API используется для ручной отправки задач worker'ам. Интерфейс поддерживает возможность поставить следующие задачи:
- > _Получи список id всех приложений в Steam_
- > _Получи данные об приложении с ID X в стране "A"_
- > _Получи данные об приложениях с ID [X, Y, Z] в странах ["A", "B", "C"]_

Под каждую задачу отведен отдельный эндпоинт, который возвращает ID Celery-задачи. Ее статус можно проверить в отдельном эндпоинте. Подробнее можно посмотреть в swagger-документации по адресу `http://<адрес оркестратора>:8888/docs.`

**Важно:** API Оркестратора считается внутренним и недоступен извне при стандартном деплое (см. пункт [Deploy](README.md#Deploy)). К нему можно обращаться используя специально отведенные для этого эндпоинты в Backend API.

API требует аутентификации: наличия access_token в заголовке запроса, который обладает scope `orchestrator/tasks` (см. [Auth](AUTH.md)).

Ограничение доступа осуществляется за счет кастомного механизма разграничения прав, аналогичного тому, что используется в Backend (см. [Механизм разграничения прав](BACKEND.md#кастомный-механизм-разграничения-прав)).

Пользовательские задачи имеют повышенный приоритет.

## TODO:

- [ ] **Lock приложений в БД:** При постановке задачи на обновление приложений блокировать их для других задач, чтобы дважды не запрашивать одно и то же (А что если задача провалится? Отдельная Celery-задача, снимающая мертвые Lock'и?).
- [ ] **Параллельное выполнение задач:** Обработка поступающих задач в отдельных потоках (не забыть про ограничение кол-ва потоков).
- [ ] **Отделить интерфейс Pika от TaskManager:** Абстрагировать `TaskManager` от конкретной реализации канала сообщений (в данном случае pika) (Dependency Inversion).
